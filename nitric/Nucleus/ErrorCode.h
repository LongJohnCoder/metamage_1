// Nucleus/ErrorCode.h
// -------------------
//
// Maintained by Joshua Juran

// Part of the Nitrogen project.
//
// Written 2002-2009 by Lisa Lippincott and Joshua Juran.
//
// This code was written entirely by the above contributors, who place it
// in the public domain.


/*
   One of the more distressing problems arising when using C code from C++
   is that C functions return error codes, and C++ code gets along better
   with exceptions.  A common approach to makng the transition is to wrap
   error codes in a class which is then thrown.
   
   But this approach doesn't produce exceptions with the fine granularity
   one expects from C++ exceptions.  Often one must catch the error class,
   test the code it contains, and rethrow those exceptions one didn't want
   to catch.
   
   These templates extend the error class approch to provide fine-grained
   exception throwing.  Consider an error code type ErrorNumber, and an
   exception class wrapper ErrorClass for that type.

   
   The classes generated by the template
   
      template < class ErrorClass, ErrorNumber number > class ErrorCode
   
   each represent a particular, numbered error.   These classes all
   descend from ErrorClass, and initialize that base class with their
   particular number.
   
   
   The function template
   
      template < class ErrorClass > void ThrowErrorCode( ErrorClass n )
   
   throws an exception representing the error given by n.  The type of the
   exception thrown is either ErrorClass or a subclass of ErrorClass.
      
      -- If the error number n has been registered, the exception has type
            ErrorCode< ErrorClass, n >
      -- Otherwise, the exception thrown has type ErrorClass.
   
   In most cases, this function isn't called directly; instead, one calls a
   wrapper function which filters out those numbers which indicate success.
   
   
   The functions
   
      template < class ErrorClass, ErrorNumber number > void RegisterErrorCode()
   
   regsiter particular error numbers, ensuring that they will be thrown as
   ErrorCode< ErrorClass, number > by ThrowErrorCode< ErrorClass >.
   
   
   --- Advanced usage ---
   
   The ErrorNumber type is inferred from the ErrorClass type by a traits class
   
      template < class ErrorClass >
      struct ErrorClassTraits
        {
         typedef typename ErrorClass::ErrorNumber ErrorNumber;
        };
   
   Error classes may specify their underlying error code type with a typedef,
   or one may use this sceme with an existing error class by specializing
   ErrorClassTraits.
   
   The template function Convert is used to convert ErrorNumber to ErrorClass
   and vice versa.  By default, it attempts an implicit conversion; if
   these conversions are not allowed, Convert may be extended to provide
   the necessary conversions.
   
   The class template ErrorCode may be specialized to provide a richer
   representation of particular errors.  For example, one might use a
   specialization derived from both ErrorClass and std::bad_alloc to
   represent a memory allocation error.

   Likewise, the function template used to throw the specific exceptions,
   
      template < class Exception > void Throw()
   
   may be specialized to modify the way a perticular code is thrown.
*/

#ifndef NUCLEUS_ERRORCODE_H
#define NUCLEUS_ERRORCODE_H

#ifndef NUCLEUS_CONVERT_H
#include "Nucleus/Convert.h"
#endif

#ifndef NUCLEUS_DEBUGGING_H
#include "Nucleus/Debugging.h"
#endif

#include <map>


#ifndef NUCLEUS_RICH_ERRORCODES
  #if defined( __MWERKS__ )
    #define NUCLEUS_RICH_ERRORCODES 0
  #else
    #define NUCLEUS_RICH_ERRORCODES 1
  #endif
#endif

#if NUCLEUS_RICH_ERRORCODES
  #define DEFINE_ERRORCODE( error_type, c_name, new_name )  typedef Nucleus::ErrorCode< error_type, c_name > new_name
#else
  #define DEFINE_ERRORCODE( error_type, c_name, new_name )  inline Nucleus::ErrorCode< error_type, 0 > new_name()  { return Nucleus::ErrorCode< error_type, 0 >( c_name ); }
#endif


namespace Nucleus
  {   
   
   template < class ErrorClass >
   struct ErrorClassTraits
     {
      typedef typename ErrorClass::ErrorNumber ErrorNumber;
     };   
   
   template < class ErrorClass, typename ErrorClassTraits<ErrorClass>::ErrorNumber number >
   class ErrorCode: public ErrorClass, public DebuggingContext
     {
      public:
	#if NUCLEUS_RICH_ERRORCODES
         ErrorCode()
           : ErrorClass( Convert<ErrorClass>( number ) ),
             DebuggingContext()
           {}
	#else
         ErrorCode( typename ErrorClassTraits<ErrorClass>::ErrorNumber errnum )
           : ErrorClass( Convert<ErrorClass>( errnum ) ),
             DebuggingContext()
           {}
	#endif
     };
	
	template < class Exception >
	void Throw()
	{
		throw Exception();
	}

   
   template < class ErrorClass >
   class ErrorCodeThrower
     {
      private:
         typedef typename ErrorClassTraits< ErrorClass >::ErrorNumber ErrorNumber;
         
         typedef std::map< ErrorNumber, void(*)() > Map;
      
         Map map;

         // not implemented:
            ErrorCodeThrower( const ErrorCodeThrower& );
            ErrorCodeThrower& operator=( const ErrorCodeThrower& );
      
      public:
         ErrorCodeThrower()
           {}
         
         template < ErrorNumber number >
         void Register()
           {
            map[ number ] = Nucleus::Throw< ErrorCode< ErrorClass, number > >;
           }
         
         void Throw( ErrorClass error ) const
           {
            typename Map::const_iterator found = map.find( Convert<ErrorNumber>( error ) );
            if ( found != map.end() )
               return found->second();
            throw error;
           }
     };


   template < class ErrorClass >
   ErrorCodeThrower<ErrorClass>& TheGlobalErrorCodeThrower()
     {
      static ErrorCodeThrower<ErrorClass> theGlobalErrorCodeThrower;
      return theGlobalErrorCodeThrower;
     }
   
   template < class ErrorClass, typename ErrorClassTraits<ErrorClass>::ErrorNumber number >
   inline void RegisterErrorCode()
     {
      if ( NUCLEUS_RICH_ERRORCODES )
      TheGlobalErrorCodeThrower<ErrorClass>().template Register<number>();
     }
   
   template < class ErrorClass >
   inline void ThrowErrorCode( ErrorClass error )
     {
	#if NUCLEUS_RICH_ERRORCODES
      TheGlobalErrorCodeThrower<ErrorClass>().Throw( error );
	#else
      throw ErrorCode< ErrorClass, 0 >( error );
	#endif
     }
  }

namespace Nucleus
{
	
	template < class ErrorClass, typename ErrorClassTraits< ErrorClass >::ErrorNumber number >
	struct ErrorCode_EndOfEnumeration
	{
	#if NUCLEUS_RICH_ERRORCODES
		
		typedef ErrorCode< ErrorClass, number > EndOfEnumeration;
		
		static bool Exception_Is_EndOfEnumeration( const EndOfEnumeration& err )
		{
			return true;
		}
		
	#else
		
		typedef ErrorCode< ErrorClass, 0 > EndOfEnumeration;
		
		static bool Exception_Is_EndOfEnumeration( const EndOfEnumeration& err )
		{
			return err == number;
		}
		
	#endif
	};
	
}

#endif
