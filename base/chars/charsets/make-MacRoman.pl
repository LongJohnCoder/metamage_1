#!/usr/bin/perl

use warnings FATAL => 'all';
use strict;

my %Unicode_for_MacRoman;

my %MacRoman_for_Unicode;

while ( <> )
{
	my ( $code, $unicode ) = m{^ 0x([[:xdigit:]]{2}) \s+ 0x([[:xdigit:]]{4}) }x or next;
	
	next if hex $code < 0x80;
	
	$Unicode_for_MacRoman{ $code     } = $unicode;
	$MacRoman_for_Unicode{ $unicode  } = $code;
}

die "Wrong number of keys\n" if keys %Unicode_for_MacRoman != 128;
die "Wrong number of keys\n" if keys %MacRoman_for_Unicode != 128;

my $decoder_table_body = join ",\n\t",
                              map { "/* 0x$_ */ 0x$Unicode_for_MacRoman{$_}" }
                                  sort { hex $a <=> hex $b }
                                       keys %Unicode_for_MacRoman;

my $encoder_map_body   = join ",\n\t",
                              map { "{ 0x$_, 0x$MacRoman_for_Unicode{$_} }" }
                                  sort { hex $a <=> hex $b }
                                       keys %MacRoman_for_Unicode;

print << "[END]";
/*
	MacRoman.cc
	-----------
	
	Generated by make-MacRoman.pl
	
	Data from <http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/ROMAN.TXT>
*/

#include "charsets/MacRoman.hh"


namespace chars
{

const unsigned short MacRoman_decoder_table[] =
{
	$decoder_table_body
};

const struct unicode_mapping MacRoman_encoder_map[] =
{
	$encoder_map_body
};

}

[END]

=pod

const unsigned short decoder_table[] =
{
	/* 0x80 */ 0x00C4,
	/* 0x81 */ 0x00C5,
	/* 0x82 */ 0x00C7,
	...
	/* 0xFD */ 0x02DD,
	/* 0xFE */ 0x02DB,
	/* 0xFF */ 0x02C7
};

const struct unicode_mapping encoder_map[] =
{
	{ 0x00A0, 0xCA },
	{ 0x00A1, 0xC1 },
	{ 0x00A2, 0xA2 },
	...
	{ 0xF8FF, 0xF0 },
	{ 0xFB01, 0xDE },
	{ 0xFB02, 0xDF }
};

=cut
