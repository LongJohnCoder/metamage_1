/*

Possible ways to compile tests

static function -- tests are compiled, but not linked or run
static invocation -- a file-static object runs the test in its constructor
static registration -- a file-static object registers the test in its constructor
	* flexible testing
		* tests can be run or not (without recompiling)
		* tests can be run interactively, chosen and initiated by user
		* tests can be sorted by file modification date.
		
	

*/

// Standard C++
#include <algorithm>
#include <numeric>
#include <vector>

#define TESTING ALINE_DEBUG


namespace Test
{
	
	// Run an individual test within a test case.
	// Called by the TEST_ASSERT macro.
	void Assert( bool condition, const char* text, const char* file, int line );
	
	// The type of functions generated by the TEST macro.
	typedef void (*TestProcPtr)();
	
	// The type of object generated by the TEST macro and supplied to a Tester.
	struct Group
	{
		TestProcPtr testProc;
		const char* label;
		const char* date;
		const char* time;
		const char* file;
		int line;
		
		Group( TestProcPtr testProc, const char* label,
                                     const char* date,
                                     const char* time,
                                     const char* file, int line );
	};
	
	// Abstract base class for running tests.
	// You can actually use this class as is -- it will run the tests,
	// but it won't record any results or produce any output.
	// The supplied Assert() calls either Passed() or Failed().
	struct TesterBase
	{
		virtual ~TesterBase()  {}
		
		void RunAll();
		
		void operator()( const Group* test )  { Run( test ); }
		
		virtual void Run( const Group* test );
		
		virtual void Assert( bool condition, const char* test, const char* file, int line );
		
		virtual void Passed( const char* test, const char* file, int line )  {}
		virtual void Failed( const char* test, const char* file, int line )  {}
	};
	
	enum Status
	{
		kTestFailed = -1,  // The test completed incorrectly.
		kTestMissed = 0,   // The test did not complete.
		kTestPassed = 1    // The test completed correctly.
	};
	
	struct Result
	{
		Status       fStatus;
		const char*  fAssertion;
		
		Result() : fStatus   ( kTestMissed ),
		           fAssertion( "" )
		{}
		
		Result( Status stat, const char* assertion ) : fStatus   ( stat      ),
		                                               fAssertion( assertion )
		{}
		
		const Result& Results() const  { return *this; }
		
		//Status AggregateStatus() const  { return fStatus; }
	};
	
	inline Status AggregateStatus( const Result& result )  { return result.fStatus; }
	
	template < class Result >
	struct CombinedStatus
	{
		Status operator()( Status stat, const Result& r )
		{
			return std::min( stat, AggregateStatus( r.Results() ) );
		}
	};
	
	template < class Result >
	Status AggregateStatus( const std::vector< Result >& results )
	{
		return std::accumulate( results.begin(),
		                        results.end(),
		                        kTestPassed,
		                        CombinedStatus< Result >() );
	}
	
	struct GroupResult
	{
		Group fGroup;
		std::vector< Result > fResults;
		
		GroupResult( const Group& group ) : fGroup( group )  {}
		
		const std::vector< Result >& Results() const  { return fResults; }
		
		//Status AggregateStatus() const;
	};
	
	typedef std::vector< GroupResult > FullResults;
	
	class SampleTester : public TesterBase
	{
		private:
			FullResults fResults;
		
		public:
			void Run( const Group* test );
			
			const FullResults& Results() const  { return fResults; }
			
			void Assert( bool condition, const char* test, const char* file, int line );
	};
	
}

#define TEST_CONCAT(a,b)         a##b
#define TEST_CONCAT2(a,b)        TEST_CONCAT(a,b)
#define TEST_APPEND_LINE(label)  TEST_CONCAT2(label,__LINE__)
#define TEST_FUNCTION()          TEST_APPEND_LINE(Test_)
#define TEST_OBJ()               TEST_APPEND_LINE(gTest_)

#ifdef TESTING
	
	#define TEST(label)  static void TEST_FUNCTION()();                      \
	                     static Test::Group TEST_OBJ()( TEST_FUNCTION(),  \
	                                                    #label,           \
	                                                    __DATE__,         \
		                                                __TIME__,         \
		                                                __FILE__,         \
		                                                __LINE__ );       \
	                     void TEST_FUNCTION()()
	
	#define TEST_ASSERT(condition)  Test::Assert( condition, #condition, __FILE__, __LINE__ )
	
#else
	
	#define TEST(label)  static void TEST_FUNCTION()()
	#define TEST_ASSERT(condition)  (void)NULL
	
#endif

